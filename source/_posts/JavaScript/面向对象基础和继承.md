---
title: 面向对象基础和创建对象的几种模式
subtitle: pattern
tags: [面向对象, JS, 构造函数]
date: 2017-06-22
categories: JavaScript
description:
---

`面向对象`是一种编程思想,很多编程语言都基于这种思想. 面向对象的语言有一个标志,那就是他们都有类的概念,而通过类可以创建任意多个具有相同属性和方法的对象. `ECMAScript` 中没有类的概念,它把对象定义为 "无序属性的集合,器属性可以包含基本值,对象或者函数", 对象的每个属性或方法都有一个名字,每个名字有映射一个值, 因此` ECMAScript `中的对象无非就是一组名值对, 值可以是任意数据.

<!--more-->

### 1. 理解对象

`JavaScript` 中的所有事物都是对象:字符串、数值、数组、函数... 对象只是带有属性和方法的特殊数据类型。

`JavaScript` 提供多个内建对象,比如 String、Date、Array 等等.

创建对象常用的方式有两种, `构造函数`和`字面量`,下面两种方式可以达到相同的效果

```javascript
// 构造函数方式创建对象
var p = new Object()
p.name = 'undo'
p.age = 26

// 字面量方式创建对象
var p = {
    name: 'undo',
    age: 26
}
```

### 2. 几种创建对象的模式

#### 2.1 单例模式

`单例模式`是项目开发中经常使用的模式,因为项目中我们可以使用单例模式来进行我们的"模块化开发"

`模块化开发`:对于一个相对来说比较大的项目,需要多人协作的开发的,我们一般情况下会根据当前项目的需求划分成几个功能版块,每个人负责一部分,同时开发,最后把每个人的代码进行合并

`单例模式` 其实就是字面量的方式创建对象,把描述同一个事物(同一个对象)的属性和方法放在一个内存空间下,起到了分组的作用,这样不同事物之间的属性即使属性名相同,相互也不会发生冲突, 把这种分组编写代码的模式叫做`"单例模式"`

```javascript
var person1 = {
    name: "Jack",
    age: 18
}

var person2 = {
    name: "John",
    age: 48
}
```

在单例模式中我们把`person1`,`person2`也叫做 `"命名空间"`
 
`单例模式` 开发中需要开辟多个命名空间,即使不同命名空间之间有相同或相似的地方也需要在各自的命名空间内再写一遍,没有封装的概念,并非面向对象编程.

`单例模式`虽然解决了分组的作用,但是不能实现批量的生产,属于手工作业模式, `工厂模式` 应运而生

#### 2.2 工厂模式

`工厂模式` 抽象了创建具体对象的过程,用函数来封装特定接口创建对象.

```javascript
function createPerson(name, age) {
    var obj = {};
    obj.name = name;
    obj.age = age;
    obj.writeJs = function () {
        console.log("my name is " + this.name + ",i can write js 啦~~");
    };
    return obj;
}
var p1 = createPerson("王小波", 48);
p1.writeJs();

var p2 = createPerson("尹华芝", 18);
p2.writeJs();
```

可以无限次的调用 `createPerson` 函数,每次它都会返回一个包含两个属性一个方法的对象. 

`工厂模式` 虽然解决了创建多个相似对象的问题,但却没有解决对象识别的问题(即怎么知道一个对象的类型),于是有了新的模式.

#### 2.3 构造函数模式

`构造函数` 可用来创建特定类型的对象, 像 `Object` 和 `Array`这样的原生构造函数, 它不再是以具体事物为研究对象,而是以一类事物为研究对象.

```javascript
function CreatePerson(name, age) {
    this.name = name;
    this.age = age;
    this.writeJs = function () {
        console.log("my name is " + this.name + ",i can write js 啦!!");
    };
}
var p1 = new CreatePerson("尹华芝", 18); // CreateJsPerson->this p1
p1.writeJs(); // writeJs->this p1

var p2 = new CreatePerson("王小波", 25); // CreateJsPerson->this p2
p2.writeJs(); // writeJs->this p2

var res = CreateJsPerson("王小波", 7);
// 这样写不是构造函数模式执行而是普通的函数执行 由于没有写return所以res=undefined  并且CreateJsPerson这个方法中的this是window
console.log(res); // undefined
```

`构造函数` 创建对象的原理

```javascript
function create(name, age) {
  var obj = {}
  obj.__proto__ = CreatePerson.prototype
  var result = CreatePerson.call(obj,name, age)
  return typeof result === 'obj' ? result : obj
}
```

> 函数的三种角色

- 普通函数: 像普通函数一样执行
- 普通对象: 可以用 `函数名.属性名` 的方式添加或访问函数的静态方法
- 构造函数: 使用 `new` 关键字操作符, 以构造函数方式运行

这三种角色灵活运用开发效率将大大提高,`jQuery` 就很巧妙的利用了函数的这一特性

`构造函数模式`和`工厂模式`的区别?

1、执行的时候

> 普通函数执行->createPerson()
> 构造函数模式->new CreatePerson()  通过new执行后,我们的CreateJsPerson就是一个类了
> 而函数执行的返回值(p1)就是CreateJsPerson这个类的一个实例

2、在函数代码执行的时候

> 相同:都是形成一个私有的作用域,然后 形参赋值->预解释->代码从上到下执行 (类和普通函数一样,它也有普通的一面)
> 不同:在代码执行之前,不用自己在手动的创建obj对象了,浏览器会默认的创建一个对象数据类型的值(这个对象其实就是我们当前类的一个实例)
> 接下来代码从上到下执行，以当前的实例为执行的主体(this代表的就是当前的实例),然后分别的把属性名和属性值赋值给当前的实例
> 最后浏览器会默认的把创建的实例返回

`构造函数模式` 虽然好用,但也有缺点,就是每个方法都需要在每个实例上创建一遍,而且他们指向了不同的内存空间.

```javascript
console.log(p1.writeJs === p2.writeJs) // false
```

创建两个完全相同任务的 `Function` 实例是没有必要的, 我们可以把 `writeJs()` 函数定义到构造函数外部,然后构造函数内 `this.writeJs = writeJs`

```javascript
function CreatePerson(name, age) {
    this.name = name;
    this.age = age;
    this.writeJs = writeJs
}

function writeJs() {
    console.log("my name is " + this.name + ",i can write js 啦!!");
}
```

但是这么做有另外的问题: 1. 在全局定义的函数实际上只能被某个对象调用,全局作用域有点名不副实. 2. 如果需要定义很多方法,那么需要定义很多的全局方法,那么这个自定义类就丝毫没有封装性可言了.

这些问题可以通过原型模式来解决.

#### 2.4 原型模式

`构造函数模式`中拥有了类和实例的概念,并且实例和实例之间是相互独立开的

基于构造函数模式的原型模式解决了方法或者属性公有的问题,即把实例之间相同的属性和方法提取成公有的属性和方法 ,把它们放在构造函数的 `prototype`上即可

```javascript
function CreatePerson(name, age) {
    this.name = name;
    this.age = age;
}

CreatePerson.prototype.writeJs = function() {
    console.log("my name is " + this.name + ",i can write js 啦!!");
}

CreatePerson.prototype.sayAge = function() {
    console.log("I'am " + this.age + "years old !");
}
```

这样 `name`,`age`是每个实例对象的私有属性, 而 `writeJs`, `sayAge` 是所有 `CreatePerson` 的实例的公有方法, 而且指向了同一内存空间

如果觉得在原型上一个个添加属性比较麻烦,可以让构造函数的原型指向一个对象, 但是对象中需要手动添加`constructor` 属性,并且指向构造函数本身

```javascript
function CreatePerson(name, age) {
    this.name = name;
    this.age = age;
}

CreatePerson.prototyp = {
    writeJs: function() {
        console.log("my name is " + this.name + ",i can write js 啦!!");
    },
    sayAge: function() {
        console.log("I'am " + this.age + "years old !");
    }
}
```

每创建一个函数,会用时创建它的`prototype`对象, 这个对象会自动获得`constructor`属性指向函数本身. 以上写法重写了默认的`prototype` 对象,因此`constructor` 属性不再指向`CreatePerson`, 而是指向`Object`.

```javascript
var p = new CreatePerson('undo', 26)

console.log(p instanceof CreatePerson) // false
console.log(p instanceof Object) // true
console.log(p.constructor == CreatePerson) // false
console.logp.constructor == Object) // true
```

`constructor` 属性很重要,可以根据它的值确定对象的类型,所以需要手动添加.

```javascript
CreatePerson.prototyp = {
    constructor: CreatePerson,
    writeJs: function() {
        console.log("my name is " + this.name + ",i can write js 啦!!");
    },
    sayAge: function() {
        console.log("I'am " + this.age + "years old !");
    }
}
```

`hasOwnProperty()` 可以区分属性是实例属性还是原型属性.

```javascript
console.log(p.hasOwnProperty('name')) // true
console.log(p.hasOwnProperty('sayAge')) // false
```

`in` 操作符, 会在通过对象能够访问给定属性时返回`true`,不区分实例属性和原型属性
```javascript
console.log('name' in p) // true
console.log('sayAge' in p) // true
```

使用`for-in`遍历对象的实例属性,可以使用下面的方法进行过滤

```javascript
function hasPrototypeProperty(object, name) {
    return !object.hasOwnProperty(name) && (name in object)
}
```

`Object.keys()` 返回一个包含所有可枚举实例属性的字符串数组

```javascript
var keys = Object.keys(p)
console.log(keys) // ['name', 'age']
```

`Object.getOwnPropertyNames()` 返回所有的实例属性无论是否可以枚举

```javascript
var keys = Object.getOwnPropertyNames(p.prototype)
console.log(keys) // ['constructor', 'writeJs', 'sayAge']
```

